# Satchel

So every player has an initial inventory size. This is their main inventory given to them from the start. It can be changed with a character update.

To start, a player needs to import a character sheet. This will set the initial inventory size, permissions, etc. This can be changed later by character updates.

To add items to the inventory, a player can receive Loot or Gift.

Loot is from the DM, also known as Server.
Gift is from another player, also known as Client.

Each of these transactions are done through file transfers of JSON objects. They ALWAYS have a required destination (so people cannot share the same item, duplicating the transaction).

All these transactions are logged and validated to be accurate and non-duplicate. Meaning, there wil be a transactional log keeping track of all these.

There won't be a log on removal of items though, such as dumping things onto the Ground.

The Ground is an empty inventory space players can use as extra temporary space. This space is used to let players dump trash. It it also the place where everything goes into if it cannot fit in the player's inventory. If it cannot fit on the Ground either, it will be permanently destroyed.

Each loot transfer: (these cannot be changed)
- Transaction Id (for Server identification)
- Source Id (the server that generated this)
- Owner Id (usually the original player id this is intended for)
- Description (for the player to know where this came from)
- Title (for style)
- Transaction Checksum (a hash to verify the contents are correct)

Each gift transfer: (these cannot be changed)
- Source id (the player giving the gift)
- Destination id (the player receiving the gift)
- Gift description (for the player, this replaces the old description)
- Gift checksum

This does mean once sealed, it cannot be re-opened by the sender. It must be resent back as another Gift.

To see if a transaction is valid, we simply check the content with the checksum. If it is okay, we then check the transaction log for the transaction id. If it not in there, we check the checksum for the transaction log. If it is correct, we append it to the log and make a new checksum. Otherwise, it has already been added.

Transaction objects should also be able to drag and drop.

Backups
- Transaction log
- Transaction checksum
- Inventory state => This is not checksum as it can have items removed. As long as item being added are always done through transactions, this should be okay.



InitialContext
- Create the root.

ContextTransaction
- Update any contextual things for future transactions in the log.

ItemTransaction
- Append to the log.

1. Master: Generates player id for each player.
2. Player: Receives the player id and generates a unique key. Sends this to the Master.
3. Master: Receives the player id with associated key. (Assumes authentic player identity)
4. Master can now send transactions to the player by id and key.

Why not just use a client-generated key? No need for player id?

What if someone changes the code in the client to use another client's key?
- This could happen if they have access to the return-key file generated by every client for the Master.
- This would then allow the client to read and process all transactions.
    - Which would allow it to impersonate someone else and gift all the items to themselves.


Diffie-Hellman Key Exchange :)
- No need to worry about man in the middle attacks, since we can trust discord.

So the player should always have a key file to open their backpack. If they lose the key file.



Every item has an id.
Each transaction owns all item ids.
These ids can be traded without server consent.


We just want to prevent duplication.

Although a digital signature would be nice, I think there's enough trust in a local group such that this is not necessary. Perhaps as a future addition.

For now, just making sure you cannot add the same item twice through transaction or gifts, and that
transactions and gifts can be guaranteed to be valid and untampered.

Public/private key for transactions are still good. Gift transactions don't need to be validated though.

This way, you cannot impersonate someone without their private key. Therefore transactions and gifts are safe. When the person loses a key, they can generate a new one and give it to the Master.

Gifts can easily be duped per person, simply by rollback to a point where you have the data. Gift it to someone, then roll forward. Now you both have it.

To validate this, simply have a 2-way transaction, where generating a gift is also a record to save, in
addition to receiving it. This way, to validate this gift, simply read both logs to see if they both
have it.

But how can the receiver be sure this is a valid gift?

Places where you receive items:
- transactions
    - requiredOwner: only the designated person can have it.
    - source/transactionId: cannot impersonate the source as this will be a mismatch once validated.
    - hash: This will make sure the transaction content was not altered. Authenticating the contents.
- gifts
    - Although any trading can be done without the server, to verify a trade occured, it must eventually
    be validated by the Master. This is done by the recepient.
        - The Master can then validate every transaction and verify the gifted item has not been traded
        elsewhere.
        - But someone can impersonate this trade agreement.
        - Digital signature on the transaction could eliminate this.
            - To deter the private key owner from sharing this, we must minimize benefits for doing so.
                - If shared, this will allow the other user to trade away ALL their items to themselves.
                - But that's it. No duplication possible since all exchanges are eventually validated by 
                the Master.
                - If key is lost, simply generate a new private/public key for the Master. (Assumes 
                authentic identity when sent).


So every player must generate a private/public key file. The public key must be sent to the Master to be
validated.

In order to backup properly, you need the backups to be signed by the Master.
Every transaction and the initial context has a gift key signed by the Master. This gift key has an activation time, which it is only valid after that time period.

A gift key is an encoded data packet of an activation time for a player when they are allowed to trade. It
is simply included in every gift exchange.

Since the player's client program signs the built packet, the data in the packet should not be alterable. Otherwise, it will fail the public key test from the receiver.

This is NOT a trade mechanism. Otherwise we would need some way to disagree with transaction before it is commited. Which needs a third party validator (the Master).

Program will always check the backup file against the Master's public key to see if it is valid. Every
backup validated has an expiration time, which it cannot be used to backup after that time. like 10 min.
If they want to backup again with the same file, they will have to request another one.

For at least that long, they cannot gift things. Otherwise, they can abuse the enabled backup time to gift and backup to restore the item.

To make sure no one will receive the gifts when backing up, every gift transaction must be encoded with the player's most recent gift key, which has an activation time.

What if they use an old gift key?
- they can. They could simply request an older backup to be validated. And then gift the item. and back up to that save. They can only do this once though, as they will no longer be able to use the new gift key.
- or they can use an old gift key and send gifts to people infinitely.
- BUT simply don't allow old gift keys to be visible.
- To do this, gift keys 

## Design

**Assumptions**
- Direct communication between Player and Master is secure and authentic.
- Client program code cannot be altered intentionally and meaningfully.

1. Player generates a public/private key pair.
2. Player sends the public key, along with name, to the Master for registration.
3. Master receives the key and puts it in the registry.
4. Master signs and sends the initial backup state.
    - This is the exact same procedure as a regular backup.
        - This can only be opened by the player with the same public key that initiated the request.
            - This is achieved by perserving integrity of the contents through an additional appened hash. Which can be
            verified and therefore means an equality check is enough.
                - NOTE: If this is not enough, consider encryption/decryption.
        - There is an expiry time of 10 minutes for the backup.
        - There is also an activation time of 10 minutes after to enable gifting.
            - If a gift is sent, the receiver will first verify the signature, then check the activation time on the gift key.
            - **WARNING:** There could be an issue where the client uses an OLD signature to gift things. Currently, this is
            detered by only using the most recent signature when gifting in the CLIENT. This could be bypassed by changing client
            behavior (like removing disabled on a button). But then we are worrying about players altering client code, which
            CANNOT be protected against unless we have a third party validator (a server). So until then, this should be sufficient.
    - The program will ONLY restore from signed backups.
        - When reading a backup, it will first verify the signature, then check the expiry time on that signature.
5. Player loads from the initial backup. They will make unsigned backups occasionally to protect their data.
    - If they need to restore, they will have to request it to be signed by Master.